# utils/vulnerability_analyzer.py
import os
import requests
import json
from dotenv import load_dotenv
from pathlib import Path
import streamlit as st

# Charger les variables d'environnement
load_dotenv()
llm_key = os.getenv("llm_key")

def analyze_vulnerabilities(raw_pages, summaries, progress_callback=None, status_callback=None):
    """
    Analyse les vuln√©rabilit√©s dans les documents
    
    Args:
        raw_pages (list): Pages extraites par LlamaParse
        summaries (list): R√©sum√©s g√©n√©r√©s par Summary Agent
        progress_callback: Fonction pour mettre √† jour la progression
        status_callback: Fonction pour afficher le statut
    
    Returns:
        list: R√©sultats de l'analyse pour chaque page
    """
    
    if not llm_key:
        st.error("Cl√© API LLM non configur√©e dans le fichier .env")
        return []
    
    results = []
    total_pages = max(len(raw_pages) if raw_pages else 0, len(summaries) if summaries else 0)
    
    if total_pages == 0:
        st.error("Aucune page √† analyser")
        return []
    
    for idx in range(total_pages):
        # Progression
        if progress_callback:
            progress = ((idx + 1) / total_pages) * 100
            progress_callback(progress)
        
        if status_callback:
            status_callback(f"Analyse page {idx + 1}/{total_pages}...")
        
        # R√©cup√©rer les donn√©es
        page_content = raw_pages[idx] if idx < len(raw_pages) else ""
        summary_data = summaries[idx] if idx < len(summaries) else {}
        
        # Extraire les informations du r√©sum√©
        if isinstance(summary_data, dict):
            page_summary = summary_data.get("pageSummary", "")
            global_summary = summary_data.get("updatedGlobalSummary", "")
            section_title = summary_data.get("sectionTitle", "")
            is_continuation = summary_data.get("isContinuation", False)
        else:
            page_summary = ""
            global_summary = ""
            section_title = ""
            is_continuation = False
        
        # Prompt am√©lior√©
        prompt = f"""
Vous √™tes un expert en analyse de risques projet. Analysez cette page et identifiez les vuln√©rabilit√©s.

CONTEXTE GLOBAL:
{global_summary[:500] if global_summary else "Non disponible"}

SECTION: {section_title}
R√âSUM√â DE LA PAGE: {page_summary}

CONTENU D√âTAILL√â:
{page_content[:2000] if page_content else "Non disponible"}

INSTRUCTIONS:
Identifiez et structurez votre r√©ponse en JSON avec:

1. √âtape_1: Liste des √©l√©ments vuln√©rables
   - √âl√©ment_vuln√©rable: nom de l'√©l√©ment
   - Justification: citation du document + explication

2. √âtape_2: Menaces associ√©es
   - √âl√©ment_vuln√©rable: reprise de l'√©l√©ment
   - Menace_associ√©e: menace identifi√©e
   - Justification: cons√©quences possibles

R√©pondez UNIQUEMENT avec le JSON structur√© entre ```json et ```.
"""
        
        # Appel API
        try:
            response = requests.post(
                "https://openrouter.ai/api/v1/chat/completions",
                headers={
                    "Authorization": f"Bearer {llm_key}",
                    "Content-Type": "application/json"
                },
                data=json.dumps({
                    "model": "deepseek/deepseek-chat",
                    "temperature": 0.3,
                    "messages": [{"role": "user", "content": prompt}]
                }),
                timeout=30
            )
            
            response.raise_for_status()
            result = response.json()['choices'][0]['message']['content']
            
            results.append({
                'page': idx + 1,
                'analysis': result,
                'section': section_title,
                'has_content': bool(page_content),
                'has_summary': bool(page_summary)
            })
            
        except requests.exceptions.Timeout:
            results.append({
                'page': idx + 1,
                'error': "Timeout - la requ√™te a pris trop de temps",
                'section': section_title
            })
        except requests.exceptions.RequestException as e:
            results.append({
                'page': idx + 1,
                'error': f"Erreur r√©seau: {str(e)}",
                'section': section_title
            })
        except Exception as e:
            results.append({
                'page': idx + 1,
                'error': f"Erreur: {str(e)}",
                'section': section_title
            })
    
    if status_callback:
        status_callback("‚úÖ Analyse termin√©e!")
    
    return results

def format_vulnerability_for_display(analysis_text):
    """
    Formate le texte d'analyse pour un meilleur affichage
    
    Args:
        analysis_text (str): Texte brut de l'analyse
    
    Returns:
        dict: Donn√©es structur√©es pour l'affichage
    """
    try:
        # Extraire le JSON du texte
        if '```json' in analysis_text:
            json_str = analysis_text.split('```json')[1].split('```')[0]
        else:
            json_str = analysis_text
        
        data = json.loads(json_str)
        
        # Normaliser les cl√©s
        vulnerabilities = []
        threats = []
        
        # √âtape 1 - Vuln√©rabilit√©s
        if '√âtape_1' in data:
            vulnerabilities = data['√âtape_1']
        elif '√âtape 1' in data:
            vulnerabilities = data['√âtape 1']
        elif 'etape_1' in data:
            vulnerabilities = data['etape_1']
        
        # √âtape 2 - Menaces
        if '√âtape_2' in data:
            threats = data['√âtape_2']
        elif '√âtape 2' in data:
            threats = data['√âtape 2']
        elif 'etape_2' in data:
            threats = data['etape_2']
        
        return {
            'vulnerabilities': vulnerabilities,
            'threats': threats,
            'raw': analysis_text
        }
        
    except Exception as e:
        return {
            'vulnerabilities': [],
            'threats': [],
            'raw': analysis_text,
            'parse_error': str(e)
        }

def save_vulnerability_report(results, output_path):
    """
    Sauvegarde le rapport en format Markdown et JSON
    
    Args:
        results (list): R√©sultats de l'analyse
        output_path (str/Path): Chemin de sortie
    
    Returns:
        bool: Succ√®s de la sauvegarde
    """
    try:
        output_path = Path(output_path)
        output_path.parent.mkdir(parents=True, exist_ok=True)
        
        # Sauvegarder en JSON
        json_path = output_path.with_suffix('.json')
        with open(json_path, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2)
        
        # Sauvegarder en Markdown
        md_path = output_path.with_suffix('.md')
        with open(md_path, 'w', encoding='utf-8') as f:
            f.write("# Rapport d'Analyse des Vuln√©rabilit√©s\n\n")
            f.write(f"Date: {Path().resolve()}\n")
            f.write(f"Pages analys√©es: {len(results)}\n\n")
            
            for result in results:
                f.write(f"---\n\n")
                f.write(f"## Page {result['page']}\n")
                f.write(f"**Section:** {result.get('section', 'N/A')}\n\n")
                
                if 'error' in result:
                    f.write(f"‚ö†Ô∏è **Erreur:** {result['error']}\n\n")
                else:
                    # Formatter l'analyse
                    formatted = format_vulnerability_for_display(result.get('analysis', ''))
                    
                    # Vuln√©rabilit√©s
                    if formatted['vulnerabilities']:
                        f.write("### üîç Vuln√©rabilit√©s Identifi√©es\n\n")
                        for vuln in formatted['vulnerabilities']:
                            element = vuln.get('√âl√©ment_vuln√©rable', vuln.get('√âl√©ment vuln√©rable', 'N/A'))
                            justif = vuln.get('Justification', 'N/A')
                            f.write(f"**{element}**\n")
                            f.write(f"> {justif}\n\n")
                    
                    # Menaces
                    if formatted['threats']:
                        f.write("### ‚ö†Ô∏è Menaces Associ√©es\n\n")
                        for threat in formatted['threats']:
                            element = threat.get('√âl√©ment_vuln√©rable', threat.get('√âl√©ment vuln√©rable', 'N/A'))
                            menace = threat.get('Menace_associ√©e', threat.get('Menace associ√©e', 'N/A'))
                            justif = threat.get('Justification', 'N/A')
                            f.write(f"**{element} ‚Üí {menace}**\n")
                            f.write(f"> {justif}\n\n")
                
                f.write(f"**Statut des donn√©es:**\n")
                f.write(f"- Contenu brut: {'‚úÖ' if result.get('has_content') else '‚ùå'}\n")
                f.write(f"- R√©sum√©: {'‚úÖ' if result.get('has_summary') else '‚ùå'}\n\n")
        
        return True
        
    except Exception as e:
        st.error(f"Erreur lors de la sauvegarde: {e}")
        return False

def export_to_excel(results, output_path):
    """
    Exporte les r√©sultats vers Excel
    
    Args:
        results (list): R√©sultats de l'analyse
        output_path (str/Path): Chemin de sortie
    
    Returns:
        bool: Succ√®s de l'export
    """
    try:
        import pandas as pd
        
        # Cr√©er les DataFrames
        vulnerabilities_data = []
        threats_data = []
        
        for result in results:
            page_num = result['page']
            section = result.get('section', 'N/A')
            
            if 'error' not in result:
                formatted = format_vulnerability_for_display(result.get('analysis', ''))
                
                # Collecter les vuln√©rabilit√©s
                for vuln in formatted['vulnerabilities']:
                    vulnerabilities_data.append({
                        'Page': page_num,
                        'Section': section,
                        '√âl√©ment Vuln√©rable': vuln.get('√âl√©ment_vuln√©rable', vuln.get('√âl√©ment vuln√©rable', 'N/A')),
                        'Justification': vuln.get('Justification', 'N/A')
                    })
                
                # Collecter les menaces
                for threat in formatted['threats']:
                    threats_data.append({
                        'Page': page_num,
                        'Section': section,
                        '√âl√©ment Vuln√©rable': threat.get('√âl√©ment_vuln√©rable', threat.get('√âl√©ment vuln√©rable', 'N/A')),
                        'Menace': threat.get('Menace_associ√©e', threat.get('Menace associ√©e', 'N/A')),
                        'Justification': threat.get('Justification', 'N/A')
                    })
        
        # Cr√©er le fichier Excel
        output_path = Path(output_path).with_suffix('.xlsx')
        with pd.ExcelWriter(output_path, engine='openpyxl') as writer:
            if vulnerabilities_data:
                df_vuln = pd.DataFrame(vulnerabilities_data)
                df_vuln.to_excel(writer, sheet_name='Vuln√©rabilit√©s', index=False)
            
            if threats_data:
                df_threats = pd.DataFrame(threats_data)
                df_threats.to_excel(writer, sheet_name='Menaces', index=False)
            
            # R√©sum√©
            summary_data = {
                'M√©trique': ['Total Pages', 'Pages avec Erreurs', 'Vuln√©rabilit√©s Totales', 'Menaces Totales'],
                'Valeur': [
                    len(results),
                    sum(1 for r in results if 'error' in r),
                    len(vulnerabilities_data),
                    len(threats_data)
                ]
            }
            df_summary = pd.DataFrame(summary_data)
            df_summary.to_excel(writer, sheet_name='R√©sum√©', index=False)
        
        return True
        
    except ImportError:
        st.warning("pandas non install√©. Impossible d'exporter vers Excel.")
        return False
    except Exception as e:
        st.error(f"Erreur lors de l'export Excel: {e}")
        return False